// src/realWorker.ts
import os from "node:os";
import { Worker as _Worker } from "node:worker_threads";
var Worker = class {
  /** @internal */
  _code;
  /** @internal */
  _parentFunctions;
  /** @internal */
  _max;
  /** @internal */
  _pool;
  /** @internal */
  _idlePool;
  /** @internal */
  _queue;
  constructor(fn, options = {}) {
    this._code = genWorkerCode(fn, options.parentFunctions ?? {});
    this._parentFunctions = options.parentFunctions ?? {};
    const defaultMax = Math.max(
      1,
      // os.availableParallelism is available from Node.js 18.14.0
      (os.availableParallelism?.() ?? os.cpus().length) - 1
    );
    this._max = options.max || defaultMax;
    this._pool = [];
    this._idlePool = [];
    this._queue = [];
  }
  async run(...args) {
    const worker = await this._getAvailableWorker();
    return new Promise((resolve, reject) => {
      worker.currentResolve = resolve;
      worker.currentReject = reject;
      worker.postMessage({ type: "run", args });
    });
  }
  stop() {
    this._pool.forEach((w) => w.unref());
    this._queue.forEach(
      ([, reject]) => reject(
        new Error("Main worker pool stopped before a worker was available.")
      )
    );
    this._pool = [];
    this._idlePool = [];
    this._queue = [];
  }
  /** @internal */
  async _getAvailableWorker() {
    if (this._idlePool.length) {
      return this._idlePool.shift();
    }
    if (this._pool.length < this._max) {
      const worker = new _Worker(this._code, { eval: true });
      worker.on("message", async (args) => {
        if (args.type === "run") {
          if ("result" in args) {
            worker.currentResolve && worker.currentResolve(args.result);
            worker.currentResolve = null;
          } else {
            if (args.error instanceof ReferenceError) {
              args.error.message += ". Maybe you forgot to pass the function to parentFunction?";
            }
            worker.currentReject && worker.currentReject(args.error);
            worker.currentReject = null;
          }
          this._assignDoneWorker(worker);
        } else if (args.type === "parentFunction") {
          try {
            const result = await this._parentFunctions[args.name](...args.args);
            worker.postMessage({ type: "parentFunction", id: args.id, result });
          } catch (e) {
            worker.postMessage({
              type: "parentFunction",
              id: args.id,
              error: e
            });
          }
        }
      });
      worker.on("error", (err) => {
        worker.currentReject && worker.currentReject(err);
        worker.currentReject = null;
      });
      worker.on("exit", (code) => {
        const i = this._pool.indexOf(worker);
        if (i > -1)
          this._pool.splice(i, 1);
        if (code !== 0 && worker.currentReject) {
          worker.currentReject(
            new Error(`Worker stopped with non-0 exit code ${code}`)
          );
          worker.currentReject = null;
        }
      });
      this._pool.push(worker);
      return worker;
    }
    let resolve;
    let reject;
    const onWorkerAvailablePromise = new Promise((r, rj) => {
      resolve = r;
      reject = rj;
    });
    this._queue.push([resolve, reject]);
    return onWorkerAvailablePromise;
  }
  /** @internal */
  _assignDoneWorker(worker) {
    if (this._queue.length) {
      const [resolve] = this._queue.shift();
      resolve(worker);
      return;
    }
    this._idlePool.push(worker);
  }
};
function genWorkerCode(fn, parentFunctions) {
  const createParentFunctionCaller = (parentPort) => {
    let id = 0;
    const resolvers = /* @__PURE__ */ new Map();
    const call = (key) => async (...args) => {
      id++;
      let resolve, reject;
      const promise = new Promise((res, rej) => {
        resolve = res;
        reject = rej;
      });
      resolvers.set(id, { resolve, reject });
      parentPort.postMessage({ type: "parentFunction", id, name: key, args });
      return await promise;
    };
    const receive = (id2, args) => {
      if (resolvers.has(id2)) {
        const { resolve, reject } = resolvers.get(id2);
        resolvers.delete(id2);
        if ("result" in args) {
          resolve(args.result);
        } else {
          reject(args.error);
        }
      }
    };
    return { call, receive };
  };
  return `
const { parentPort } = require('worker_threads')
const parentFunctionCaller = (${createParentFunctionCaller.toString()})(parentPort)

const doWork = (() => {
  ${Object.keys(parentFunctions).map(
    (key) => `const ${key} = parentFunctionCaller.call(${JSON.stringify(key)});`
  ).join("\n")}
  return (${fn.toString()})()
})()

parentPort.on('message', async (args) => {
  if (args.type === 'run') {
    try {
      const res = await doWork(...args.args)
      parentPort.postMessage({ type: 'run', result: res })
    } catch (e) {
      parentPort.postMessage({ type: 'run', error: e })
    }
  } else if (args.type === 'parentFunction') {
    parentFunctionCaller.receive(args.id, args)
  }
})
  `;
}

// src/fakeWorker.ts
import { createRequire } from "node:module";
var FakeWorker = class {
  /** @internal */
  _fn;
  constructor(fn, options = {}) {
    const argsAndCode = genFakeWorkerArgsAndCode(
      fn,
      options.parentFunctions ?? {}
    );
    const require2 = createRequire(import.meta.url);
    this._fn = new Function(...argsAndCode)(require2, options.parentFunctions);
  }
  async run(...args) {
    try {
      return await this._fn(...args);
    } catch (err) {
      if (err instanceof ReferenceError) {
        err.message += ". Maybe you forgot to pass the function to parentFunction?";
      }
      throw err;
    }
  }
  stop() {
  }
};
function genFakeWorkerArgsAndCode(fn, parentFunctions) {
  return [
    "require",
    "parentFunctions",
    `
${Object.keys(parentFunctions).map((key) => `const ${key} = parentFunctions[${JSON.stringify(key)}];`).join("\n")}
return (${fn.toString()})()
  `
  ];
}

// src/workerWithFallback.ts
var WorkerWithFallback = class {
  /** @internal */
  _disableReal;
  /** @internal */
  _realWorker;
  /** @internal */
  _fakeWorker;
  /** @internal */
  _shouldUseFake;
  constructor(fn, options) {
    this._disableReal = options.max !== void 0 && options.max <= 0;
    this._realWorker = new Worker(fn, options);
    this._fakeWorker = new FakeWorker(fn, options);
    this._shouldUseFake = options.shouldUseFake;
  }
  async run(...args) {
    const useFake = this._disableReal || this._shouldUseFake(...args);
    return this[useFake ? "_fakeWorker" : "_realWorker"].run(...args);
  }
  stop() {
    this._realWorker.stop();
    this._fakeWorker.stop();
  }
};
export {
  Worker,
  WorkerWithFallback
};
